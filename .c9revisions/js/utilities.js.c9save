{"ts":1351189016204,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"function draw_line(x1, y1, x2, y2, color, width) {       \n    var color = color || 'red',\n        width = width || 1;\n\n    grid.draw(function(){            \n        this.beginPath();\n        this.moveTo(x1, y1);\n        this.lineTo(x2, y2);\n        this.strokeStyle = color;\n        this.lineWidth = width;\n        this.stroke();\n        this.closePath();\n    });\n\n}\nfunction draw_fov2(x1, y1, min, max, distance, color1, color2) {\n   // min,max = radian values\n    var distance = distance || 50,\n        color1 = color1 || \"rgba(255, 50,50, .15)\",\n        color2 = color2 || \"rgba(255, 50,50, .8)\",\n        drawValues = drawValues || false;\n        \n        \n     grid.draw(function(){\n         \n        this.fillStyle = color1;\n        this.strokeStyle = color2;\n        this.moveTo(x1,y1);\n       \n       \n        this.beginPath();\n       \n        this.moveTo(((distance) * Math.cos(max)) + x1,((distance) * Math.sin(max)) + y1);\n        this.arc(x1,y1, distance ,max + (2*Math.PI), min + (2*Math.PI),true);\n        this.arc(x1,y1, distance+50, min +(2*Math.PI),max + (2*Math.PI), false );\n    \n        \n        \n        this.closePath();\n        this.fill();\n        this.stroke();\n       \n     });\n}\nfunction draw_fov(x1, y1, min, max, distance, color1, color2, drawValues,note) {\n   // min,max = radian values\n    var distance = distance || 50,\n        color1 = color1 || \"rgba(255, 50,50, .15)\",\n        color2 = color2 || \"rgba(255, 50,50, .8)\",\n        drawValues = drawValues || false;\n     grid.draw(function(){\n         \n        this.fillStyle = color1;\n        this.strokeStyle = color2;\n        this.moveTo(x1,y1);\n        this.beginPath();\n        this.arc(x1,y1, distance ,max + (2*Math.PI), min + (2*Math.PI),true);\n        this.lineTo(x1,y1);\n        this.closePath();\n        this.fill();\n        this.stroke();\n        \n        if(drawValues){ \n            var lblDistance = distance;\n            draw_radian_line(x1,y1,min,lblDistance, \"rgba(0,0,0, .5)\");\n            draw_radian_line(x1,y1,max,lblDistance, \"rgba(0,0,0, .4)\");\n            \n            var minX = (lblDistance * Math.cos(min)) + x1,\n                minY = (lblDistance * Math.sin(min)) + y1,\n                maxX = (lblDistance * Math.cos(max)) + x1,\n                maxY = (lblDistance * Math.sin(max)) + y1,\n                minLblY = grid.container_height - (14*(Number(note)+2))+2,\n                maxLblY =  14+(14*Number(note)+1);\n                \n                \n            this.fillStyle    = '#000';\n            this.font         = '8px sans-serif';\n            this.textBaseline = 'top';\n            this.fillStyle     = '#fff';\n            \n            var minTextWidth = this.measureText(min.toFixed(1) + ' ['+note+'] min').width;\n            var maxTextWidth = this.measureText(max.toFixed(1) + ' ['+note+'] max').width;\n            \n            this.fillRect(minX-2, minLblY -2 , minTextWidth+4, 12);\n            draw_line(minX,minY,minX,minLblY, 'rgba(255,255,255,.3)');\n            \n            \n            this.fillRect(maxX-2,maxLblY -2, maxTextWidth+4, 12);\n            draw_line(maxX,maxY,maxX,maxLblY, 'rgba(255,255,255,.3)');\n            \n            this.fillStyle     = '#000';\n            \n            this.fillText(min.toFixed(1)+' ['+note+'] min', minX, minLblY);\n            this.fillText(max.toFixed(1)+' ['+note+'] max', maxX,maxLblY);\n        }\n    });\n}\nfunction draw_radian_line(x, y, radian, distance, color, width) {\n    \n    var _x = (distance * Math.cos(radian)) + x,\n        _y = (distance * Math.sin(radian)) + y;\n    \n        draw_line(x,y,_x,_y,color,width);                 \n}  \nfunction draw_triangle(x1,y1,x2,y2,x3,y3, color1, color2) {\n    \n    var colors = ['255,0,0','0,255,0','0,0,255','0,130,130','255,200,0'];\n    \n    function c() {\n            var index = Math.floor(Math.random() * colors.length);\n            return colors[index];\n    }\n    var rCol =  c();\n    \n    \n    var canvas = document.getElementById('canvas');\n    if (canvas.getContext){\n        var ctx = canvas.getContext('2d'),\n         color1 = color1 || rCol+',0.1',\n         color2 = color2 || rCol+',0.9';\n\n        grid.draw(function(){\n            this.fillStyle = \"rgba(\"+color1+\")\";\n            this.strokeStyle = \"rgba(\"+color2+\")\";\n            this.globalAlpha = 1.0;\n            this.beginPath();\n            this.moveTo(x1, y1);\n            this.lineTo(x2, y2);\n            this.lineTo(x3, y3);\n            this.lineTo(x1, y1);\n            this.closePath();\n            this.stroke();\n            this.fill();\n        });\n    }\n}\nfunction get_extended_line_coord(x1,y1,x2,y2) {\n    var slope = (y2 - y1) / (x2 - x1),\n        yintercept = y1 - slope * x1,\n        xr = (x2 > x1) ? grid.container_width : 0 ,\n        yr = slope * xr + yintercept;\n        \n        return {\n            x: xr,\n            y: yr\n        };\n}\nfunction distance_test(hex_a,hex_b){\n    var dist,\n        // must be hex space coords\n        A_x = hex_a[0],\n        A_y = hex_a[1],\n        B_x = hex_b[0],\n        B_y = hex_b[1];\n\n    // calculate distance using hexcoords as per previous algorithm     \n    \n    dx = B_x - A_x;\n    dy = B_y - A_y;\n\n    if (Math.sin(dx) == Math.sin(dy)) {\n        \n        dist = Math.max(Math.abs(dx), Math.abs(dy));\n    }\n    else {\n        dist = Math.abs(dx) + Math.abs(dy);\n    }\n    dist2 = (Math.abs(dx) + Math.abs(dy) + Math.abs(dx-dy)) / 2;            \n    console.log('dist_test : '+dist);\n    console.log('dist_test2 : '+dist2);\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":5468}]],"length":5468}
