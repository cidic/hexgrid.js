{"ts":1351188972343,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"function MultiDimensionalArray(iRows,iCols) {\n\tvar i, j, a = new Array(iRows);\n\tfor (i=0; i < iRows; i++) {\n\t\ta[i] = new Array(iCols);\n\t\tfor (j=0; j < iCols; j++) {\n\t\t\ta[i][j] = \"\";\n\t\t}\n\t}\n\treturn(a);\n} \nfunction get_lowest_positive_index(arr) {\n\treturn arr.reduce(function(prev_value, current_value, index, array) {\n\n\t\tif((current_value > 0) &&\n\t\t\t((arr[prev_value] < 0 && current_value > 0)\n\t\t\t||\n\t\t\t(current_value < arr[prev_value] && arr[prev_value] > 0)\n\t\t\t)){\n\t\t\treturn index;\n\t\t}\n\t\telse{\n\t\t\treturn prev_value;\n\t\t}\n\t},0);\n}\nfunction get_highest_negative_index(arr) {\n\treturn arr.reduce(function(prev_value, current_value, index, array) {\n\n\t\tif((current_value < 0) &&\n\t\t\t((arr[prev_value] > 0 && current_value < 0)\n\t\t\t||\n\t\t\t(current_value > arr[prev_value] && arr[prev_value] < 0)\n\t\t\t)){\n\t\t\treturn index;\n\t\t}\n\t\telse{\n\t\t\treturn prev_value;\n\t\t}\n\t},0);\n} \n    \nfunction BinaryHeap(scoreFunction){\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n  push: function(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n    // Allow it to bubble up.\n    this.bubbleUp(this.content.length - 1);\n  },\n\n  pop: function() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return result;\n  },\n\n  remove: function(node) {\n    var len = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (var i = 0; i < len; i++) {\n      if (this.content[i] == node) {\n        // When it is found, the process seen in 'pop' is repeated\n        // to fill up the hole.\n        var end = this.content.pop();\n        if (i != len - 1) {\n          this.content[i] = end;\n          if (this.scoreFunction(end) < this.scoreFunction(node))\n            this.bubbleUp(i);\n          else\n            this.sinkDown(i);\n        }\n        return;\n      }\n    }\n    throw new Error(\"Node not found.\");\n  },\n\n  size: function() {\n    return this.content.length;\n  },\n\n  bubbleUp: function(n) {\n    // Fetch the element that has to be moved.\n    var element = this.content[n];\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = Math.floor((n + 1) / 2) - 1,\n          parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      }\n      // Found a parent that is less, no need to move it further.\n      else {\n        break;\n      }\n    }\n  },\n\n  sinkDown: function(n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n        element = this.content[n],\n        elemScore = this.scoreFunction(element);\n\n    while(true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2, child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n            child1Score = this.scoreFunction(child1);\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore)\n          swap = child1N;\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n            child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap == null ? elemScore : child1Score))\n          swap = child2N;\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap != null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n};"]],"start1":0,"start2":0,"length1":0,"length2":4384}]],"length":4384}
