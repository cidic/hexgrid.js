{"ts":1351189682241,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"function node_distance(node1,node2){\n    var x1 = node1.center.x,\n        y1 = node1.center.y,\n        x2 = node2.center.x,\n        y2 = node2.center.y,\n        dx = Math.abs(x2-x1),\n        dy = Math.abs(y2-y1);\n        \n\treturn Math.round(Math.sqrt((dx*dx) + (dy*dy)));\n}\nvar currentPathID = 0;\nfunction node_distance(node1,node2){\n    var x1 = node1.center.x,\n        y1 = node1.center.y,\n        x2 = node2.center.x,\n        y2 = node2.center.y,\n        dx = Math.abs(x2-x1),\n        dy = Math.abs(y2-y1);\n        \n    return Math.round(Math.sqrt((dx*dx) + (dy*dy)));\n}\nvar currentPathID = 0;\nfunction path(start_x, start_y, end_x, end_y) {\n    \n    \n    // number to identify a path\n    currentPathID++;\n    // Check cases path is impossible from the start.\n\tif(start_x == end_x && start_y == end_y)\n        alert('start and end are the same hex');\n\tif(grid.hex(start_x,start_y).impassible !== false) \n        alert('start hex not accessable');\n\tif(grid.hex(end_x,end_y).impassible !== false)\n        alert('end hex not accessable');\n    if(start_x > grid.mapsize_x || start_y > grid.mapsize_y || start_x < 0 || start_y < 0)\n        alert('start hex falls outside grid bounds');    \n    if(end_x > grid.mapsize_x || end_y > grid.mapsize_y || end_x < 0 || end_y < 0)\n        alert('end hex falls outside grid bounds');\n    \n    var startNode = grid.hex(start_x,start_y),\n        endNode = grid.hex(end_x,end_y),\n        priorityQueue = new BinaryHeap(function(node){return node.f;});\n    \n    startNode.f = 0;\n    startNode.g = 0;\n    \n    var currentNode = startNode;\n    \n    while(currentNode != endNode){\n        \n        \n        currentNode.pathID = currentPathID; // Mark this node as being in the closed set.\n        \n        var adj = currentNode.get_adjacent.filter(function(node) {\n             // Retrieve the neighbours of this node which are passable not in the closed set.\n            return !node.impassible && (node.pathID != currentPathID);\n        });    \n        \n        _.each(adj, function(adjNode){\n            var d = node_distance(currentNode,adjNode);\n            console.log(d);\n            var adjNode_g = currentNode.g + d;\n            \n            if (adjNode.pathID == -currentPathID) {\n                // adjNode exists in the open set.\n                if (adjNode.g < adjNode_g) return; // The new path is not better.\n                priorityQueue.remove(adjNode);\n            }\n            else adjNode.pathID = -currentPathID; // Mark as being in the open set.\n            \n            adjNode.g = adjNode_g;\n            var adjNode_h = node_distance(adjNode, endNode)\n            adjNode.f = adjNode_g + adjNode_h;\n            adjNode.parent = currentNode;\n            priorityQueue.push(adjNode);\n        \n        });\n\n        // get last node from priority queue\n        currentNode = priorityQueue.pop();\n        \n        /*\n        if(priorityQueue.length === 0){\n            console.log('priorityQueue.length === 0');\n            return false;\n        }\n\n        */\n        if(typeof currentNode == 'undefined'){\n            console.log('typeof currentNode == undefined');\n            return false;   \n        }\n    }\n    console.log(priorityQueue);\n        // The actual path must be constructed using the parent pointers.\n        var path = [currentNode];\n        while (currentNode = currentNode.parent) path.unshift(currentNode);        \n        \n    _.each(path, function(hex) {\n       hex.setColor('yellow'); \n    });\n    \n}"]],"start1":0,"start2":0,"length1":0,"length2":3476}]],"length":3476}
