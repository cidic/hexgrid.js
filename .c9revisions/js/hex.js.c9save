{"ts":1351189036121,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"function hex(args) {\n    // args {hexgrid, x, y, corners, blocks_los, color, edge, center_x, center_y, arc_data, distance_data}\n    var args = args || {};\n    \n    \n    this.x           = args.x;\n    this.y           = args.y;\n    this.hexgrid     = args.hexgrid;\n    this.center = {\n        x : args.center_x,\n        y : args.center_y\n        \n    };\n    this.corners     = args.corners;\n    \n    this.arc_data    = args.arc_data;\n    //this.domObj\n    \n    this.blocksLos   = args.blocks_los || false;\n    this.color       = args.color || 'green';\n    this.edge        = args.edge || false;\n    this.distanceTo  = args.distanceData || {};\n        \n    \n}\nhex.prototype.set_traversal_data = function() {\n\n\n    this.get_s_hex  = this.hexgrid.hex(this.x, this.y + 1);\n    this.get_ne_hex = this.hexgrid.hex(this.x +1, ((this.x&1) === 0)? this.y - 1 : this.y);\n    \n    this.get_nw_hex = this.hexgrid.hex(this.x - 1,((this.x&1) === 0)? this.y - 1 : this.y);\n    this.get_n_hex  = this.hexgrid.hex(this.x, this.y - 1 );\n    this.get_se_hex = this.hexgrid.hex(this.x + 1, ((this.x&1) === 0)? this.y : this.y + 1);\n    this.get_sw_hex = this.hexgrid.hex(this.x - 1, ((this.x&1) === 0)? this.y : this.y + 1);\n\n    this.get_adjacent = [\n         this.get_s_hex\n        ,this.get_ne_hex\n        ,this.get_nw_hex\n        ,this.get_n_hex\n        ,this.get_se_hex\n        ,this.get_sw_hex\n        ].filter(function(val) { return val !== false; });\n        \n}\nhex.prototype.set_hex_arc_data = function() {\n    \n    // arc data\t\n\t// targetHex.arc_data[x][y] contains arc/radian data of grid.hex[x][y] relative to origin hex(targetHex)\n\t\n\t// minRadian (most left (counterclockwise))\n\t// maxRadian (most right(clockwise))\n\t// minRadianCorner\n\t// maxRadianCorner\n\tfor(var i_x = 0, len = this.hexgrid.mapsize_x; i_x < len; i_x++){\n\t\tfor(var i_y = 0, len2 = this.hexgrid.mapsize_y; i_y < len2; i_y++){\n\t\t\tthis.arc_data[i_x][i_y] = this.get_min_max_hex_corners(this, this.hexgrid.hex(i_x,i_y), false);\n           \n\t\t}\t\n\t}\n\t\n}\nhex.prototype.setColor = function(color){\n    var color = color || 'blue',\n        $target = $('#'+this.x+'-'+this.y+ ' div');            \n        \n    this.color = color;\n\t$target.attr('class','hex '+color);\n    return this;\n}\nhex.prototype.get_min_max_hex_corners = function(hex1,hex2, drawLine){\n    // returns the min and max radian of the corners of hex2 when hex1 is the origin\n\t// may want to be able to process a collection of hexes to find min/max; turn hex1 into an array of hex objects and do a foreach loop\n\t\n\tvar drawLine = typeof(drawLine) != 'undefined' ? drawLine : true,\n\t\tradian = [],\n\t\tmin_radian_index = 0,\n\t\tmax_radian_index = 0; //index of the lowest value\n\n\tfor (var i=0;i<6;i++) {\n\t\tradian[i] = Math.atan2(hex2.corners[i].y - hex1.center.y, hex2.corners[i].x - hex1.center.x); // get radian of each corner point\t\t\t\t\n\t\t\t\n\t\tif(radian[i] < radian[min_radian_index]) {\n\t\t\tmin_radian_index = i;\n\t\t}\n\t\t\n\t\tif(radian[i] > radian[max_radian_index]) {\n\t\t\tmax_radian_index = i;\n\t\t}\n\t\tif(drawLine){\n\t\t\tdraw_line(hex1.center.x, hex1.center.y,hex2.corners[i].x,hex2.corners[i].y, 'yellow');\n\t\t}\n\t}\t\n\t\n\tvar min_rad,\n\t\tmax_rad;\n\t\t\n\t// if hex is NOT on the wraparound point (left of origin hex where PI becomes -PI)\n\t// check that the absolute value of the difference of the max and min is > pi.\n\t// that happens, then it goes the other direction, take the smallest positive value and largest negative value instead of the actual smallest/largest.\n\t\n\tif((Math.abs(radian[max_radian_index] - radian[min_radian_index])) > Math.PI){\n\t\tmin_radian_index = get_lowest_positive_index(radian);\t\t\t\n\t\tmax_radian_index = get_highest_negative_index(radian);\n\t}\n\t\n\t\tmin_rad = radian[min_radian_index];\n\t\tmax_rad = radian[max_radian_index];\n\t\n\tvar result =    {\n\t\t\t\t\t\tmin :   {\n\t\t\t\t\t\t\t\t\tx : hex2.corners[min_radian_index].x,\n\t\t\t\t\t\t\t\t\ty : hex2.corners[min_radian_index].y,\n\t\t\t\t\t\t\t\t\t'radian' : min_rad\n\t\t\t\t\t\t\t\t},\t\t\n\t\t\t\t\t\tmax :   {\n\t\t\t\t\t\t\t\t\tx : hex2.corners[max_radian_index].x,\n\t\t\t\t\t\t\t\t\ty : hex2.corners[max_radian_index].y,\n\t\t\t\t\t\t\t\t\t'radian' : max_rad\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\n    return result;\n}\nhex.prototype.get_hex_loop = function(distance){\n    return get_hex_loop(this, distance);\n}\n\nfunction get_hex_loop(hex, distance) {\n    \t// get array of hexes in loop around 'hex'\n        // consider memoizing this\n\n\tvar\tdistance = distance || 1,\n\t\torigin_x = hex.x,\n\t\torigin_y = hex.y,\n        _x = origin_x,\n        _y = origin_y - distance,\n\t\tnext = grid.hex(origin_x, origin_y - distance),\n        result = [];\n\n    s_hex  = function(x,y){ return {x : x, y : y + 1}};\n    ne_hex = function(x,y){ return {x : x +1, y : ((x&1) === 0)? y - 1 : y}};\n    nw_hex = function(x,y){ return {x : x - 1, y : ((x&1) === 0)? y - 1 : y}};\n    n_hex  = function(x,y){ return {x : x, y :  y - 1 }};\n    se_hex = function(x,y){ return {x : x + 1, y : ((x&1) === 0)? y : y + 1}};\n    sw_hex = function(x,y){ return {x : x - 1, y : ((x&1) === 0)? y : y + 1}};\n\n    var directions = [\n         se_hex\n        ,s_hex\n        ,sw_hex\n        ,nw_hex\n        ,n_hex\n        ,ne_hex\n    ];\n\n    for(var d = 0; d < 6; d++){\n        for(var i = 0; i < distance; i++){\n            result.push(next);\n            var next_coords = directions[d](_x,_y);\n\n            _x = next_coords.x;\n            _y = next_coords.y;\n\n            next = grid.hex(_x,_y);\n\t    }\n    }\n\treturn result;\n}\n\n\n\nfunction UnitType(args){\n    var args = args || {};\n    /* example args\n    {\n        name : 'infantry',\n        displayName: 'Infantry',\n        movement : {\n            'default' : 3,\n            'forest' : 3,\n            'building' : 3\n        }\n    }\n    */\n    _.extend(this, args);\n    \n    \n}\n\nvar unitTypes = {\n    'infantry' : new UnitType({\n        name : 'infantry',\n        displayName: 'Infantry',\n        movement : {\n            'default' : 3,\n            'forest' : 3,\n            'building' : 3\n        }\n    }),\n    'afv_light' : new UnitType({\n        name : 'afv_light',\n        displayName: 'Light Armored Fighting Vehicle',\n        movement: {\n            'default' : 6,\n            'forest' : 3,\n            'building' : -1\n        }\n    }),\n}\nfunction TerrainType(args) {\n    var args = args || {};\n    \n    this.name           = args.name;\n  \n}\n\nvar terrainTypes ={\n    'default' : new TerrainType({\n        name : 'default'\n    }),\n    'forest' : new TerrainType({\n        name : 'forest'\n    })\n};\n\n\nconsole.log(unitTypes);\n\n\n    "]],"start1":0,"start2":0,"length1":0,"length2":6415}]],"length":6415}
