{"ts":1351189478409,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// angleSet.js by Joseph Crowe <joseph.crowe@live.co.uk>\r\n// Requires jQuery.\r\nfunction angleSet (\r\n/*\r\n    {min:min0, max:max0}, {min:min1, max:max1} ... | arrayOfIntervals |\r\n    edge0, edge1, edge2, ... edgeN | arrayOfEdges\r\n*/\r\n) {\r\n    // A set of angles composed of a finite number of segments which are either full or empty. The\r\n    // angles in full segments are included in the set, and the angles in empty segments are not.\r\n    // The segments are encoded as a series of distinct edges numbered 0 to N-1, where segment X\r\n    // spans from edge X to edge (X+1)%N. When there are no edges, a single segment, -1, spans all\r\n    // angles. When inverted == false, all all even-numbered edges are full and all odd-numbered\r\n    // edges are empty; when inverted == true, the opposite is true. Edges should be given as angles\r\n    // in radians a normalised form such that, for each edge E, -PI < E <= PI.\r\n\r\n    // The edges given as arguments to this constructor must be distinct and in ascending order\r\n    // except for the final edge which may be greater than the first edge to indicate that the final\r\n    // segment straddles the angle PI.\r\n\r\n    // new angleSet()\r\n    //     is an empty set, containing no angle.\r\n\r\n    // new angleSet(E)\r\n    //     is a full set, containing all angles, where E is any valid edge.\r\n\r\n    // new angleSet(A, B)\r\n    //     contains all angles between A and B, sweeping in the positive direction.\r\n\r\n    // new angleSet(B, A)\r\n    //     is the inverse of new angleSet(A, B).\r\n\r\n    // new angleSet({min:A, max:B}, {min:C, max:D}, ... )\r\n    //     is equivalent to new angleSet() followed by addInterval(A, B); addInterval(C, D); ...\r\n\r\n    // new angleSet([A, B, C, ... ])\r\n    //     is equivalent to new angleSet(A, B, C, ... ), where A, B, C, ... are edges or intervals.\r\n\r\n    var args = (arguments[0] instanceof Array) ? arguments[0] : arguments;\r\n    args = Array.prototype.slice.call(args); // Convert to a new Array.\r\n\r\n    this.inverted = false;\r\n\r\n    if (typeof args[0] == \"object\") {\r\n        // Construct from a set of intervals.\r\n        this.edges = [];\r\n        args.forEach($.proxy(function (interval) {\r\n            this.addInterval(interval.min, interval.max);\r\n        }, this));\r\n    } else {\r\n        // Construct from a set of edges.\r\n        this.edges = args;\r\n        if (this.edges[this.edges.length - 1] < this.edges[0]) {\r\n            // If the last edge is less than the first, the subset being selected is the inverse of\r\n            // that where the last edge is moved to the beginning.\r\n            this.edges.unshift(this.edges.pop());\r\n            this.invert();\r\n        }\r\n        if (this.edges.length & 1) {\r\n            // If there is an odd number of edges, the subset being selected is the inverse of that\r\n            // where the first edges is removed.\r\n            this.edges.shift();\r\n            this.invert();\r\n        }\r\n    }\r\n}\r\n\r\nangleSet.TOLERANCE = 0.01;\r\n// The maximum distance a given angle can be from the edge of a full interval for that angle to be\r\n// considered a member of the interval.\r\n\r\nangleSet.prototype.copy = function () {\r\n    // Return an independent copy of this angleSet.\r\n    var copy = new angleSet(this.edges);\r\n    copy.inverted = this.inverted;\r\n    return copy;\r\n};\r\n\r\nangleSet.prototype.invert = function () {\r\n    // Inverts this angleSet such that all angles not included are now included, and vice versa.\r\n    this.inverted = !this.inverted;\r\n};\r\n\r\nangleSet.prototype.isFull = function () {\r\n    // Returns true if all angles are included in this set, or false otherwise.\r\n    return (!this.edges.length && this.inverted);\r\n}\r\n\r\nangleSet.prototype.isEmpty = function () {\r\n    // Returns true if no angles are included in this set, or false otherwise.\r\n    return !(this.edges.length || this.inverted);\r\n}\r\n\r\nangleSet.prototype.makeFull = function () {\r\n    // Modifies this angle set so that every angle is included.\r\n    this.edges = [];\r\n    this.inverted = true;\r\n}\r\n\r\nangleSet.prototype.makeEmpty = function () {\r\n    // Modifies this angle set so that no angle is included.\r\n    this.edges = [];\r\n    this.inverted = false;\r\n}\r\n\r\nangleSet.prototype.findSegment = function (angle) {\r\n    // Returns the segment number in which the given angle lies, using a binary search.\r\n    for (var start = 0, end = this.edges.length - 1, middle;;) {\r\n        if (end < start) return (this.edges.length - 1); // Angle lies in last segment\r\n        middle = (start + end) >> 1; // floor((start + end) / 2)\r\n        var offset = angle - this.edges[middle];\r\n        if (offset < -angleSet.TOLERANCE) {\r\n            end = middle - 1; // Sought angle lies in a lower segment.\r\n        } else if (offset > angleSet.TOLERANCE) {\r\n            if ((middle == this.edges.length - 1) ||\r\n                (angle < this.edges[middle + 1] - angleSet.TOLERANCE))\r\n               return middle; // Sought angle lies in this segment.\r\n            else start = middle + 1 // Sought angle may lie in a higher segment.\r\n        } else {\r\n            // Sought angle lies on the boundary between two segments; choose the one that is full.\r\n            return this.segmentIsFull(middle) ? middle : ((middle || this.edges.length) - 1)\r\n        }\r\n    }\r\n};\r\n\r\nangleSet.prototype.segmentIsFull = function (segment) {\r\n    // Returns true if the segment with the given number is full, or false if it is empty.\r\n    return ((segment & 1) == this.inverted) // (segment is odd) XNOR this.inverted\r\n};\r\n\r\nangleSet.prototype.getInterval = function (segment) {\r\n    // Returns an interval in the form {min:A, max:B} giving the ranges of angles contained in the\r\n    // segment with the given number, where B <= A implies that the interval straddles the angle PI,\r\n    // and A = B implies a full interval.\r\n    if (segment == -1) return {min:0, max:0};\r\n    return {min:this.edges[segment], max:this.edges[(segment + 1) % this.edges.length]};\r\n};\r\n\r\nangleSet.prototype.eachInterval = function (handler) {\r\n    // Execute the given function for each full segment in the set, passing arguments (min, max)\r\n    // giving the interval of angles in that segment (see getInterval). If the given function\r\n    // returns a value that is not undefined, iteration will stop and that value will be returned.\r\n    if (this.isFull()) return handler(0, 0);\r\n    for (var n = this.inverted ? 1 : 0; n < this.edges.length; n += 2) {\r\n        var interval = this.getInterval(n);\r\n        var result = handler(interval.min, interval.max);\r\n        if (result !== void 0) return result;\r\n    }\r\n}\r\n\r\nangleSet.prototype.getIntervals = function () {\r\n    // Returns an Array containing all full segments in this set, each in the form {min:A, max:B},\r\n    // as described in getInterval.\r\n    var intervals = [];\r\n    this.eachInterval(function (min, max) { intervals.push({min:min, max:max}); });\r\n    return intervals;\r\n};\r\n\r\nangleSet.prototype.containsAngle = function (angle) {\r\n    // Returns true if the given angle is contained in this set, or otherwise returns false.\r\n    return this.segmentIsFull(this.findSegment(angle))\r\n};\r\n\r\nangleSet.prototype.containsInterval_internal = function (min, max, segment) {\r\n    // Returns the same value as containsInterval, on the conditions that:\r\n    // - the interval touches the given full segment at both ends; and\r\n    // - this set and the interval are both non-full.\r\n    if (segment == this.edges.length - 1) {\r\n        segment = this.getInterval(segment);\r\n        return ((min >= segment.max) && (max <= segment.min)) == (max < min);\r\n    } else return (max > min);\r\n}\r\n\r\nangleSet.prototype.containsInterval = function (min, max) {\r\n    // Returns true if every angle between the given min and max values is included in the set, or\r\n    // otherwise returns false.\r\n    var minSegment = this.findSegment(min);\r\n    return (this.segmentIsFull(minSegment) && (this.findSegment(max) == minSegment))\r\n        && ((minSegment == -1)\r\n            || ((min != max) && this.containsInterval_internal(min, max, minSegment)));\r\n};\r\n\r\nangleSet.prototype.containsSet = function (set) {\r\n    // Returns true if every angle included in the given set is also included in this set; otherwise\r\n    // returns false. This function will return true if the two sets are equivalent.\r\n    return !set.eachInterval(function (min, max) {\r\n        if (!this.containsInterval(min, max)) return true;\r\n    });\r\n};\r\n\r\nangleSet.prototype.addInterval = function (min, max) {\r\n    // Add the given angle interval to this set such that all angles between min and max are\r\n    // included in this set.\r\n    \r\n    if (this.isFull()) return;\r\n    \r\n    var offset = min - max;\r\n    if ((0 <= offset) && (offset <= angleSet.TOLERANCE)) return this.makeFull(); // Full interval.\r\n    \r\n    // Determine where new section of edges is to be inserted.\r\n    var minSegment = this.findSegment(min), maxSegment = this.findSegment(max);\r\n    if (this.segmentIsFull(minSegment)) {\r\n        if ((minSegment == maxSegment) && !this.containsInterval_internal(min, max, minSegment))\r\n            return this.makeFull(); // A full set is formed.\r\n        min = this.edges[minSegment];\r\n    }\r\n    else minSegment = (min < this.edges[minSegment]) ? 0 : (minSegment + 1);\r\n    if (this.segmentIsFull(maxSegment)) {\r\n        maxSegment = (maxSegment + 1) % this.edges.length\r\n        max = this.edges[maxSegment]\r\n    } else if (max < this.edges[maxSegment]) maxSegment = -1;\r\n    \r\n    // Splice in new section of edges.\r\n    if (max < min) {\r\n        this.edges.splice(minSegment, this.edges.length, min);\r\n        this.edges.splice(0, maxSegment + 1, max);\r\n        this.inverted = true;\r\n    } else this.edges.splice(minSegment, maxSegment - minSegment + 1, min, max);\r\n};\r\n\r\nangleSet.prototype.addSet = function (set) {\r\n    // Add the given angleSet to this set such that all angles in that set are included in this set.\r\n    set.eachInterval($.proxy(this.addInterval, this));\r\n};"]],"start1":0,"start2":0,"length1":0,"length2":9967}]],"length":9967}
