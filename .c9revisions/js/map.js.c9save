{"ts":1348434476432,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"function hexgrid(args){\n    \n    var args = args || {};\n    this.mapsize_x = args.mapsize_x;\n    this.mapsize_y = args.mapsize_y;\n    this.hexes = MultiDimensionalArray(this.mapsize_x,this.mapsize_y);\n    \n    this.hex_width = args.hex_width;\n    this.hex_height = args.hex_height;\n    \n    this.hex_corner_offset = args.hex_corner_offset;\n\tthis.map_pixel_height = this.hex_height * this.mapsize_y;\n\tthis.container_width = (this.hex_width - this.hex_corner_offset) * this.mapsize_x + this.hex_corner_offset;\n\tthis.container_height = this.hex_height * this.mapsize_y + (this.hex_height/2) + 2;\n\n    this.blockingHexes = args.blockingHexes;\n    \n    this.generateHexes();\n    \n    if(this.blockingHexes.length > 0){\n        for(var i =0,len = this.blockingHexes.length; i <len; i++){\n            var _x = this.blockingHexes[i].x,\n                _y = this.blockingHexes[i].y;\n                this.hex(_x,_y).blocksLos = true;\n        }\n    }   \n    this.eachHex(function(x,y, hex){\n            hex.set_hex_arc_data();\n            hex.set_traversal_data();\n    });\n    \n    this.generate_arc_data();\n    \n    $($.proxy(function(){\n        \n        this.container = document.getElementById(args.containerId);\n        this.canvas = document.getElementById(args.canvasId);\n        \n        this.container.innerHTML = this.markup;\n        \n        $(this.canvas).attr('width',this.container_width);\n        $(this.canvas).attr('height',this.container_height);\n        $(this.container).width(this.container_width);\n        $(this.container).height(this.container_height);\n    }, this));\n    \n    \n    this.getCtx = function(){                \n        return (this.canvas.getContext)? this.canvas.getContext('2d') : null;\n    };\n    \n    this.draw = function(drawFunction){\n        if(this.canvas && this.canvas.getContext){\n            var ctx = this.canvas.getContext('2d');\n            drawFunction.apply(ctx);\n        }\n    } \n\n    \n    \n}\n    hexgrid.prototype.hex = function (x,y){\n        if(\n            this.hexes[x] !== undefined\n        &&  this.hexes[x] !== null\n        &&  this.hexes[x][y] !== undefined\n        &&  this.hexes[x][y] !== null\n        )\n        {\n            return this.hexes[x][y];\n        }\n        else {\n            return false;   \n        }\n    };\n    \n    hexgrid.prototype.eachHex = function(func, context){\n        // use hexes[x][y] instead of hex(x,y) we can make the assumption that all hexes returned exist, so skipp checking if undefined\n                         \n\n        for (var x=0; x < this.mapsize_x; x++) {\n\t\t\tfor (var y=0; y < this.mapsize_y; y++) { \n                var thisHex = this.hexes[x][y];\n                   var context = context || thisHex;\n                     \n                func.apply(context,[x,y, thisHex]);  \n\t\t\t}\n        }\n    };\n\n\n    hexgrid.prototype.generateHexes = function(){\n        var map_markup = '',\n            z_index = this.mapsize_y;\n        for (var x = 0; x < this.mapsize_x; x++) {\n            for (var y = 0; y < this.mapsize_y; y++) {\n                \n         \n         var hexEdge = function(){\n                        \n                            \n                            if((0 < x && x < this.mapsize_x) && (0 < y && y < this.mapsize_y)){\n                                return null;\n                            }\n                            else if(x === 0 && y === 0){\n                                return 'top_left';\n                            }\n                            else if(x === 0 && y == this.mapsize_y){\n                                return 'bottom_left';\n                            }\n                            else if(x == this.mapsize_x && y === 0){\n                                return 'top_right';\n                            }\n                            else if(x == this.mapsize_x && y == this.mapsize_y){\n                                return 'bottom_right';\n                            }\n                            else if(y === 0) {\n                                return 'top';\n                            }\n                            else if(x == this.mapsize_x){\n                                return 'right';\n                            }\n                            else if(y == this.mapsize_y) {\n                                return 'bottom';\n                            }\n                            else if(x === 0){\n                                return 'left';\n                            }\n                                    \n                        }\n         \n         \n         \n                var hex_x = (x * (this.hex_width - this.hex_corner_offset)),\n                    hex_y = ( (x%2 === 0)? (y * this.hex_height) : (y * this.hex_height) + (this.hex_height/2) ),\n                    \n                    hex_args = {\n                                \n                        // args {x,y,corners,arc_data,blocks_los,color,edge, center_x, center_y}\n                         x : x\n                        ,y : y\n                        ,center_x : (hex_x + (this.hex_width/2))\n        \t\t\t\t,center_y : (hex_y + (this.hex_height/2))\n        \t\t\t\t\t\t\n                        ,hexgrid : this\n                        ,color : 'green'\n                        ,corners : [\n                            {   x : hex_x, \n                                y : hex_y + (this.hex_height/2)\n                            },\n                            {\tx : hex_x + this.hex_corner_offset,\n                                y : hex_y\n                            },\n                            {\n                                x : hex_x + this.hex_width - this.hex_corner_offset,\n                                y : hex_y\n                            },\n                            {\n                                x : hex_x + this.hex_width, \n                                y : hex_y + (this.hex_height/2)\n                            },\n                            {\n                                x : hex_x + this.hex_width - this.hex_corner_offset,\n                                y : hex_y + this.hex_height\n                            },\n                            {\n                                x : hex_x + this.hex_corner_offset,\n                                y : hex_y + this.hex_height\n                            }\n                        ]\n                        ,arc_data : MultiDimensionalArray(this.mapsize_x,this.mapsize_y)\n                        ,edge : hexEdge()\n                    }\n               this.hexes[x][y] = new hex(hex_args);\n\n\n                map_markup +='<div id=\"'+ x + '-' + y +'\" class=\"hex-wrap hex array_space_'+x+'_'+y+'\" style=\"position:absolute;z-index:'+ hex_y +';left:' + hex_x + 'px;top:' +  hex_y + 'px;\">';\n                map_markup +='<div class=\"hex green\">';\t\t\t\t\t\t\n                map_markup +='<span style=\"position:absolute;left:10px;top:5px;\">'+x+','+y+'</span>';\n                map_markup +='</div></div>';\n\n                z_index--;\n\t\t    }\n        }\n        this.markup = map_markup;\n        \n     \n     \n    }\n     hexgrid.prototype.exportData = function() {\n        return JSON.stringify(grid.hexes,function(k,v){return((k==='get_adjacent' || k==='hexgrid' || k==='get_n_hex' || k==='get_ne_hex' || k==='get_nw_hex' || k==='get_s_hex' || k ==='get_se_hex' || k==='get_se_hex' || k==='get_sw_hex')?undefined:v);});\n    }\n    hexgrid.prototype.importData = function(data) {\n        this.hexes = data;\n          this.eachHex(function(x,y){\n            this.hex(x,y).set_traversal_data();\n        });\n    }\n    hexgrid.prototype.randomBlocking = function(hexesToBlock){\n            for(var i = 0; i<hexesToBlock; i++){\n                var rX = Math.floor(Math.random() * grid.mapsize_x), \n                    rY = Math.floor(Math.random() * grid.mapsize_y);\n                grid.hex(rX,rY).blocksLos = true;\n                grid.hex.setColor('blue');\n            }\n        }\n \n    hexgrid.prototype.getRandomHexes = function(frequency) {\n        var arr = [],\n            frequency = frequency || 0.08;\n            \n        this.eachHex(function(x,y,hex){\n             //   console.log(hex);\n                if (Math.random() < frequency) arr.push(hex);\n            });\n        \n        return arr;\n    }\n hexgrid.prototype.generate_arc_data = function(){\n    // returns the min and max radian of the corners of hex2 when hex1 is the origin\n    // may want to be able to process a collection of hexes to find min/max; turn hex1 into an array of hex objects and do a foreach loop\n\t\n\tvar hex1 = this.hex(0,0),\n        arc_data = {};\n    \n\n\t\n    this.eachHex(function (x, y) {\n\n        if ((x != 0) || (y != 0)) {\n\n            var thisArcData = get_arc_data(this.hex(x,y)),\n                min = thisArcData.min,\n                max = thisArcData.max;\n                \n             // Create necessary empty columns.\n            if (!(x in arc_data)) arc_data[x] = {};\n            if (!(-x in arc_data)) arc_data[-x] = {};\n            \n            // Populate bottom-right.\n            arc_data[x][y] = thisArcData;\n\n            // Odd columns must be shifted up by 1 hex on the top.\n            var topY = -y - (x & 1);\n            \n            // Mirror bottom-right onto top-right.\n            arc_data[x][topY] = {\n                min: -max,\n                max: -min\n            };\n            \n            // Mirror bottom-right onto top-left;\n            arc_data[-x][topY] = {\n                min: (min > 0) ? (min - Math.PI) : (min + Math.PI),\n                max: (max > 0) ? (max - Math.PI) : (max + Math.PI)\n            };\n            \n            // Mirror top-left onto bottom-left:\n            arc_data[-x][y] = {\n                min: -arc_data[-x][topY].max,\n                max: -arc_data[-x][topY].min\n            };\n        }\n    }, this); \t\n\t\n\t\n\t//console.log(arc_data);\n    /*\n    for( var i in arc_data){\n        \n       \n        for( var j in arc_data[i]){  \n             \n            console.log(i+','+j);\n        }\n    }\n    */\n    \n    this.arc_data = arc_data;\n\n    function get_arc_data(hex2){\n        var radian = [],\n            min_radian_index = 0,\n            max_radian_index = 0; //index of the lowest value\n            \n        for(var i=0;i<6;i++) {\n            radian[i] = Math.atan2(hex2.corners[i].y - hex1.center.y, hex2.corners[i].x - hex1.center.x); // get radian of each corner point\t\t\t\t\n\t\t\t\n            if(radian[i] < radian[min_radian_index]) {\n                min_radian_index = i;\n            }\n            \n            if(radian[i] > radian[max_radian_index]) {\n                max_radian_index = i;\n            }\n            \n        }\t\n\t\t\n        // if hex is NOT on the wraparound point (left of origin hex where PI becomes -PI)\n        // check that the absolute value of the difference of the max and min is > pi.\n        // that happens, then it goes the other direction, take the smallest positive value and largest negative value instead of the actual smallest/largest.\n\t\n\t    if((Math.abs(radian[max_radian_index] - radian[min_radian_index])) > Math.PI){\n\t\t    min_radian_index = get_lowest_positive_index(radian);\t\t\t\n\t\t    max_radian_index = get_highest_negative_index(radian);\n\t    }\n        return  {\n                    min : radian[min_radian_index],\n                    max : radian[max_radian_index]\t\t\t\n\t\t        };\n    }\n    \n    \n }\n   "]],"start1":0,"start2":0,"length1":0,"length2":11294}]],"length":11294}
