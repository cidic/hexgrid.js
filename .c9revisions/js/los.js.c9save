{"ts":1348434522244,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"    function get_min_max_group_hex_corners(hex1,hex_group){\n        // returns the min and max radian of the corners of hex_group when hex1 is the origin\n        // hex groups should only contain 1 or 2 hexes\n        // if there are 2 hexes\n        // we know the first ( hex_group[0] )is the left(counterclockwise) most\n        // and the second ( hex_group[1] ) is the right(clockwise) most\n        // because the arcs are cycled clockwise to form the groups\n\n\t\tvar hex_first = hex_group[0],\n\t\t\t// get last hex in group (if there is 1 hex it will be the same as the first)\n\t\t\thex_last = hex_group[hex_group.length - 1],\n            \n            hex_first_x_offset = hex_first.x - hex1.x,\n            hex_first_y_offset = hex_first.y - hex1.y - (hex1.x & hex_first_x_offset & 1),\n            \n            \n            hex_last_x_offset = hex_last.x - hex1.x,\n            hex_last_y_offset = hex_last.y - hex1.y - (hex1.x & hex_last_x_offset & 1);\n           \n            \n            /*\n            console.log('hex_first : '+hex_first.x+','+hex_first.y);\n            console.log('hex_first_offset : '+hex_first_x_offset+','+hex_first_y_offset);\n            \n            console.log('hex_last : '+hex_last.x+','+hex_last.y);\n            console.log('hex_last_offset : '+hex_last_x_offset+','+hex_last_y_offset);\n            */\n            var result =    {\n\t\t\t\t\t\t\tmin : grid.arc_data[hex_first_x_offset][hex_first_y_offset].min,\n\t\t\t\t\t\t\tmax : grid.arc_data[hex_last_x_offset][hex_last_y_offset].max\n\t\t\t\t\t\t};\n        return result;\n\t}\n    \n\tfunction hex_inside_angleSet(originHex, targetHex, angleSet){\n        // Returns true if targetHex, is visible from originHex at every angle in angleSet.\n        if (targetHex === false) return false;\n        var interval = originHex.arc_data[targetHex.x][targetHex.y];\n\t\treturn angleSet.containsInterval(interval.min.radian, interval.max.radian);\n\t}\n\n    function get_los_blocking_hex_groups(hexes, validateFunc) {\n        // TODO consider filtering out hexes already out of los as per los_arc_groups\n\t\t// creates an array of los blocking arcs from hexes in the loop with properties that block los\n\n\t    var prev_item_valid = false,\n\t        data_groups = [],\n\t\t\tgroup_start_index,\n\t\t\tfirst_item_valid = false,\n\t\t\tlast_value;\n\n\t    hexes.reduce(function(previousValue, currentValue, index, array){\n\n\t        var item_valid = validateFunc(currentValue);\n\n\t\t\tif(index === 0){\n\t\t\t\tfirst_item_valid = item_valid;\n\t\t\t}\n\n\t        if(item_valid &&  !prev_item_valid) { //start new group\n\n\t\t\t\tdata_groups.push([currentValue]);\n\t\t\t\tgroup_start_index = index;\n\n\n\t        }\n\t        else if(!item_valid && prev_item_valid){ //close group)\n\t\t\t\tif(index - group_start_index > 1) {\n\t\t\t\t\t// if this group has more then one hex in it, to prevent the same hex being saved as start and end\n\t\t\t\t\tdata_groups[data_groups.length - 1].push(previousValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t}\n\t        }\n\t        prev_item_valid = item_valid;\n\n\t\t\tif(index === array.length - 1){\n\t\t\t\tlast_value = currentValue;\n\n\t\t\t}\n                return array[index];\n\n\t    }, 0);\n\n\t\tif(prev_item_valid){\n\n\t\t\tif(first_item_valid){\n\t\t\t\t// if the first and last hexes are valid\n\t\t\t\tvar last_group = data_groups[data_groups.length - 1],\n\t\t\t\t\tfirst_group = data_groups[0];\n\n\t\t\t\t// concat the last hex in the first group and the first hex in the and last group\n\t\t\t\t// save them to the last group\n\t\t\t\tdata_groups[data_groups.length - 1] = last_group.concat(first_group[first_group.length - 1]);\n\n\t\t\t\t//delete the first group\n\t\t\t\tdata_groups.splice (0,1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//close any open groups\n\t\t\t\tdata_groups[data_groups.length - 1].push(last_value);\n\t\t\t}\n\t\t}\n\t    return data_groups;\n\t}\n\n\tfunction get_los_angleSet(origin_hex, blocking_hex_groups) {\n\t    if (!blocking_hex_groups.length) return null;\n\t\tvar result = new angleSet;\n        \n\t\tfor(var i = 0, len = blocking_hex_groups.length; i<len; i++) {\n        \n\t\t\tvar corners = get_min_max_group_hex_corners(origin_hex, blocking_hex_groups[i]);\n\t\t\tresult.addInterval(corners.min, corners.max);\n\n\t\t\t// draw lines for testing purposes\n\n            /*\n            draw_triangle(\n                origin_hex.center.x,\n                origin_hex.center.y,\n                arc_groups.min.x,\n                arc_groups.min.y,\n                arc_groups.max.x,\n                arc_groups.max.y,\n                '200,100,100,0.3',\n                '250,50,50,0.9'\n            );\n            */\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfunction los_tester(){\n\n\t\tfunction blocks_los(hex){\n\t\t\tvar blocks = !!hex.blocksLos;\n\t\t\tif(blocks){ hex.setColor('blue'); }\n\t\t\treturn blocks;\n\t\t}\n        \n\t\tvar origin_hex = grid.hex(10,10),\n\t\t\tmax_loop_radius = 100,\n\t\t\tlos_angleSet = new angleSet,\n            visible_hexes = [];\n\n        origin_hex.setColor('yellow')\n\n\t\tfor(var loop_radius = 1; loop_radius <= max_loop_radius; loop_radius++){\n\n\t\t    var loop_hexes = get_hex_loop(origin_hex, loop_radius); // array of all hexes in loop\n\n            // array of los blocking hex groups from latest hex loop\n            var blocking_hex_groups = get_los_blocking_hex_groups(loop_hexes, blocks_los);\n\n\t\t\t// angleSet containing all angles blocked from view at this radius.\n            var new_los_angleSet = get_los_angleSet(origin_hex, blocking_hex_groups);\n\n            if (new_los_angleSet) {\n                // Draw FOV arcs for each newly encountered segment which is blocked from view.\n                new_los_angleSet.eachInterval(function (min, max) {\n                    draw_fov2(\n                        origin_hex.center.x,\n                        origin_hex.center.y,\n                        min,\n                        max,\n                        loop_radius * grid.hex_height,\n                        \"rgba(50, 50,250, .15)\",\n                        \"rgba(0,0,250, .9)\"\n                    );\n                });\n\n                // Merge newly encountered FOV arcs with master angleSet.\n                los_angleSet.addSet(new_los_angleSet);\n            }\n\n            if(!los_angleSet.isEmpty()) {\n                // filter out hexes that are not within the los_arc_groups color them white\n                // TODO exclude them from being processed as blocking hexes?\n                for(var i = loop_hexes.length; i--;) {\n                    if(hex_inside_angleSet(origin_hex, loop_hexes[i], los_angleSet)){\n                        if(loop_hexes[i].blocksLos === false) loop_hexes[i].setColor('white');\n                        \n                    }\n                    // add to visible list\n                    else {\n                       visible_hexes.push(loop_hexes[i]);\n                    }\n                }\n            }\n\t\t\thexes = []; // reset hexes\n\n\t\t}\n        //console.log(visible_hexes);\n\t}"]],"start1":0,"start2":0,"length1":0,"length2":6727}]],"length":6727}
